# AI Self-Play Engine 設計書

> **Version**: 1.0.0
> **Status**: Final
> **Created**: 2026-02-09
> **Author**: 足軽1号（ashigaru1）
> **Origin**: cmd_089 AI自己対戦エンジン実装時に発見・提案、cmd_093 で殿承認

---

## 1. スキル概要

### 1.1 目的

AI同士を自動対局させるエンジンの実装パターンをスキル化する。
探索エンジンの評価、パラメータ比較、学習データ生成など、
AI対戦を大量に自動実行するシステムの構築手順を提供する。

### 1.2 ユースケース

| ユースケース | 説明 | 主な処理 |
|---|---|---|
| AI強度テスト | 異なる探索深度のAI同士を対戦させ勝率を測定 | 非対称深度設定 + 統計集計 |
| 評価関数の比較 | 新旧パラメータのAI同士で対局しElo推定 | 世代管理 + 結果永続化 |
| 棋譜データ生成 | 学習用の棋譜を大量に自動生成 | 並列実行 + ファイル保存 |
| リグレッションテスト | AIエンジン変更後に性能劣化がないか検証 | 自動実行 + 統計比較 |
| シミュレーション | ゲーム以外（LLM評価等）の対戦型ベンチマーク | 汎用対戦ループ |

### 1.3 背景

neo_shogi プロジェクト（cmd_089）でAI自己対戦エンジンを実装した際、
以下のパターンが汎用的であることを発見した：

- **並列実行管理**: Semaphoreによる同時実行数制限 + 非同期タスク管理
- **進捗追跡**: スレッドセーフな状態管理 + ポーリングAPI
- **結果永続化**: 対局完了即時のJSON保存
- **管理UI**: 設定入力 + 進捗バー + 結果テーブル

これらは将棋に限らず、チェス、囲碁、カードゲーム、さらにはLLM評価や
シミュレーションなど、あらゆる対戦型の自動実行システムに適用可能である。

### 1.4 提案理由

- ゲームAI開発で頻出するパターン
- 探索エンジン + バリアント設定 + 並列管理 + 結果永続化の組み合わせは汎用的
- 言語・フレームワークを問わず適用可能

### 1.5 承認情報

- **提案者**: 足軽1号（ashigaru1）、cmd_089 で発見
- **承認**: 殿承認済み、cmd_093

---

## 2. パターンの構成要素

### 2.1 バックエンド

| 要素 | 役割 | 実装例（Haskell） |
|---|---|---|
| Config型 | 対局数・深度・バリアント等の設定 | `SelfPlayConfig` |
| Result型 | 個別対局の結果（勝敗・手数・評価値・棋譜） | `SelfPlayResult` |
| Status型 | セッション全体の進行状況 | `SelfPlayStatus` |
| Session型 | ミュータブルなセッション状態 | `TVar SelfPlayStatus` |
| 対局ループ | AI同士が交互に手を打つ再帰ループ | `gameLoop` |
| 並列管理 | Semaphore + async による有界並列実行 | `QSem + async` |
| 結果保存 | 完了した対局をJSONファイルとして即時保存 | `BL.writeFile` |
| API層 | 開始・状態取得・結果取得の3エンドポイント | Servant routes |

### 2.2 フロントエンド

| 要素 | 役割 | 実装例（React） |
|---|---|---|
| 設定フォーム | 対局数・深度・並列数等の入力 | `<input>` + state |
| 進捗表示 | プログレスバー + ライブカウンター | ポーリング + `%` 計算 |
| 結果テーブル | 完了した対局の一覧表示 | `<table>` + map |
| 統計サマリ | 勝率・平均手数等の集計表示 | クライアント側計算 |
| 状態管理 | idle/running/done のステートマシン | `useState` |
| ポーリング | 2秒間隔でstatus+resultsを取得 | `setInterval` |

### 2.3 API契約

```
POST /api/selfplay/start   → { sessionId }
GET  /api/selfplay/status   → { total, completed, inProgress, results }
GET  /api/selfplay/results  → [{ gameId, result, moves, eval, ... }]
```

---

## 3. 関連スキル

| スキル | 関係 |
|---|---|
| `lobby-game-bridge` | ロビー→ゲーム作成の橋渡し（対人戦）。self-playは対AI戦で補完関係 |
| `websocket-game-sync` | リアルタイム同期。self-playは非同期バッチ処理で対照的 |
| `web-audio-sfx-generator` | UI/UXレイヤー。self-playの結果表示時のフィードバックに利用可能 |

---

## 4. 制限事項

### 4.1 計算コスト
- 探索深度が深いほど指数関数的に計算時間が増加
- 大規模盤面（36x36等）は現実的な時間で完了しない場合がある
- `maxConcurrent` の適切な設定が重要（CPU コア数以下を推奨）

### 4.2 メモリ
- 並列対局数が多い場合、各対局の探索テーブルがメモリを消費
- 結果をメモリに蓄積する場合、大量対局で肥大化に注意

### 4.3 キャンセル
- 現在の参考実装ではキャンセル機構は未実装
- 本スキルではキャンセルパターンも含めて記述

---

## 5. 参考資料

- neo_shogi SelfPlay.hs: 参考実装（Haskell）
- neo_shogi SelfPlayPanel.tsx: 参考実装（React）
- cmd_089 報告書: 実装の詳細と知見
